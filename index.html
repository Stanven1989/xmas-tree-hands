<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Hand-Driven Xmas Tree · Three.js + MediaPipe Hands</title>

  <!-- ES Module Shims (for Import Maps compatibility on older mobile Safari) -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --matte-green:#0b3d2e;
      --gold:#d4af37;
      --red:#b11226;
      --ink:#070a0c;
      --panel: rgba(10,18,16,.62);
      --panel2: rgba(4,8,10,.45);
      --line: rgba(212,175,55,.35);
      --soft: rgba(255,255,255,.08);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(120% 120% at 50% 30%, #0a1412 0%, #06080a 55%, #040506 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", sans-serif;
      overflow:hidden;
    }

    #app{
      position:fixed; inset:0;
      display:block;
    }

    canvas#gl{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    /* Cinematic look: vignette + haze */
    .cinema-vignette{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 42%, rgba(0,0,0,0) 40%, rgba(0,0,0,.55) 100%),
        radial-gradient(80% 60% at 50% 0%, rgba(212,175,55,.10) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(177,18,38,.08) 0%, rgba(0,0,0,0) 40%);
      mix-blend-mode:screen;
      opacity:.9;
    }

    .film-grain{
      position:absolute; inset:-20%;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.025) 0 1px, rgba(0,0,0,0) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.018) 0 1px, rgba(0,0,0,0) 1px 4px);
      opacity:.25;
      transform:rotate(2deg);
      animation: grain 7s linear infinite;
      mix-blend-mode:overlay;
      filter: blur(.2px);
    }
    @keyframes grain{
      0%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
      50%{ transform:translate3d(2%, 1%, 0) rotate(2deg); }
      100%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
    }

    .hud{
      position:absolute;
      left:12px; right:12px;
      top:12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      pointer-events:none;
    }

    .panel{
      pointer-events:auto;
      flex:1 1 auto;
      max-width:820px;
      padding:12px 12px 10px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .brand{
      display:flex; gap:10px; align-items:center;
      min-width:260px;
    }
    .badge{
      width:12px; height:12px; border-radius:999px;
      background:var(--gold);
      box-shadow:
        0 0 0 2px rgba(212,175,55,.18),
        0 0 18px rgba(212,175,55,.45);
    }
    .title{
      font-weight:700;
      letter-spacing:.3px;
      font-size:14px;
      line-height:1.2;
    }
    .subtitle{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }

    .controls{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-left:auto;
    }

    button, .file{
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(212,175,55,.38);
      color:var(--text);
      background:linear-gradient(180deg, rgba(11,61,46,.65), rgba(6,10,12,.55));
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      font-weight:650;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
    }
    button:active{ transform: translateY(1px); }
    button.secondary{
      border-color: rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      color: rgba(255,255,255,.86);
    }
    button.danger{
      border-color: rgba(177,18,38,.55);
      background: linear-gradient(180deg, rgba(177,18,38,.25), rgba(0,0,0,.18));
    }

    input[type="file"]{
      display:none;
    }
    label.file{
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .dot-red{ width:8px; height:8px; border-radius:999px; background:var(--red); box-shadow:0 0 14px rgba(177,18,38,.55); }
    .dot-green{ width:8px; height:8px; border-radius:999px; background:var(--matte-green); box-shadow:0 0 14px rgba(11,61,46,.55); border:1px solid rgba(212,175,55,.25); }

    .tips{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(212,175,55,.22);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(255,255,255,.78);
    }
    .chip{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius:999px;
      padding:6px 10px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .chip b{
      color:rgba(255,255,255,.92);
      font-weight:700;
    }

    .status{
      margin-left:auto;
      font-size:12px;
      color:rgba(255,255,255,.70);
      display:flex; align-items:center; gap:8px;
    }
    .led{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .led.on{
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.55);
    }

    /* Focus overlay */
    .focusOverlay{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:16px 12px 22px;
      pointer-events:none;
      opacity:0;
      transform: translate3d(0, 10px, 0);
      transition: opacity .25s ease, transform .25s ease;
    }
    .focusOverlay.show{
      opacity:1;
      transform: translate3d(0,0,0);
    }
    .focusCard{
      pointer-events:auto;
      width:min(680px, calc(100vw - 24px));
      border-radius:18px;
      border:1px solid rgba(212,175,55,.40);
      background: linear-gradient(180deg, rgba(0,0,0,.52), rgba(8,12,14,.62));
      box-shadow: 0 22px 70px rgba(0,0,0,.58);
      backdrop-filter: blur(12px);
      padding:14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .focusCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(60% 120% at 20% 0%, rgba(212,175,55,.18), rgba(0,0,0,0) 55%),
                  radial-gradient(60% 120% at 80% 0%, rgba(177,18,38,.12), rgba(0,0,0,0) 55%);
      pointer-events:none;
    }
    .focusCard h3{
      margin:0;
      font-size:14px;
      letter-spacing:.4px;
      position:relative;
    }
    .focusCard p{
      margin:8px 0 0;
      font-size:13px;
      line-height:1.55;
      color: rgba(255,255,255,.86);
      position:relative;
      white-space:pre-wrap;
    }
    .focusCard .small{
      margin-top:10px;
      font-size:12px;
      color: rgba(255,255,255,.65);
      position:relative;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius:10px;
      padding:6px 10px;
    }

    /* Hidden video source (required for MediaPipe) */
    video#cam{
      position:absolute;
      right:12px; bottom:12px;
      width:120px; height:160px;
      opacity:0;
      pointer-events:none;
      transform: translateZ(0);
    }

    /* Small screen adjustments */
    @media (max-width:420px){
      .brand{ min-width: 220px; }
      .panel{ padding:10px; }
      button, .file{ padding:9px 10px; }
      .tips{ gap:8px; }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="gl"></canvas>
    <div class="cinema-vignette"></div>
    <div class="film-grain"></div>

    <div class="hud">
      <div class="panel">
        <div class="row">
          <div class="brand">
            <span class="badge"></span>
            <div>
              <div class="title">Hand-Driven Sketch Control · 3D Particles + Photo Cloud Christmas Tree</div>
              <div class="subtitle">Three.js / WebGL · MediaPipe Hands · Cinematic Bloom</div>
            </div>
          </div>

          <div class="controls">
            <button id="btnStart">Enable Hand Tracking</button>
            <label class="file" for="fileInput">
              <span class="dot-red"></span>
              Upload Photos
            </label>
            <input id="fileInput" type="file" accept="image/*" multiple />
            <button id="btnReset" class="secondary">Reset Scene</button>
            <button id="btnHelp" class="secondary">How to Use</button>
          </div>

          <div class="status">
            <span id="led" class="led"></span>
            <span id="statusText">Hand tracking is off (touch drag is available)</span>
          </div>
        </div>

        <div class="tips" id="tips" style="display:none;">
          <span class="chip"><span class="dot-green"></span><b>Open palm</b> → Scatter mode</span>
          <span class="chip"><span class="dot-red"></span><b>Close fist</b> → Cone mode</span>
          <span class="chip"><b>Move your palm</b> → Rotate (in Scatter mode)</span>
          <span class="chip"><b>Thumb–index pinch</b> → “Click” to pick a photo + greeting</span>
          <span class="chip"><b>Touch drag</b> → Rotate (Scatter) · <b>Double-tap</b> → Pick a photo</span>
        </div>
      </div>
    </div>

    <div id="focusOverlay" class="focusOverlay">
      <div class="focusCard">
        <h3 id="focusTitle">Holiday Greeting</h3>
        <p id="focusText"></p>
        <div class="small">
          <span class="kbd">Close fist: Cone mode</span>
          <span class="kbd">Open palm: Scatter mode</span>
          <span class="kbd">Pinch again: Next random photo</span>
        </div>
      </div>
    </div>

    <video id="cam" playsinline></video>
  </div>

  <script type="module-shim">
    /*
      Notes:
      - Mobile camera permission typically requires HTTPS (or localhost).
      - On iOS, Safari is recommended due to WebKit limitations in other shells.
    */

    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

    const COLORS = {
      matteGreen: new THREE.Color("#0b3d2e"),
      gold: new THREE.Color("#d4af37"),
      red: new THREE.Color("#b11226"),
      bg0: new THREE.Color("#040506"),
      bg1: new THREE.Color("#0a1412")
    };

    const canvas = document.getElementById("gl");
    const statusText = document.getElementById("statusText");
    const led = document.getElementById("led");
    const btnStart = document.getElementById("btnStart");
    const btnReset = document.getElementById("btnReset");
    const btnHelp = document.getElementById("btnHelp");
    const tips = document.getElementById("tips");
    const fileInput = document.getElementById("fileInput");

    const focusOverlay = document.getElementById("focusOverlay");
    const focusTextEl = document.getElementById("focusText");

    const videoEl = document.getElementById("cam");

    // ---------------------------
    // Utils
    // ---------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const damp = (current, target, lambda, dt) => {
      // Exponential smoothing: stable across FPS
      const t = 1 - Math.exp(-lambda * dt);
      return current + (target - current) * t;
    };

    function makeRadialSpriteTexture({ inner = "rgba(212,175,55,1)", outer = "rgba(212,175,55,0)" } = {}) {
      const c = document.createElement("canvas");
      c.width = 128; c.height = 128;
      const ctx = c.getContext("2d");
      const g = ctx.createRadialGradient(64, 64, 6, 64, 64, 64);
      g.addColorStop(0, inner);
      g.addColorStop(1, outer);
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, 128, 128);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      return tex;
    }

    function makeStripeTexture() {
      const c = document.createElement("canvas");
      c.width = 256; c.height = 64;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, c.width, c.height);

      // Candy stripes
      for (let i = -64; i < c.width + 64; i += 28) {
        ctx.save();
        ctx.translate(i, 0);
        ctx.rotate(Math.PI / 10);
        ctx.fillStyle = "rgba(177,18,38,0.95)";
        ctx.fillRect(0, -40, 12, 140);
        ctx.restore();
      }

      // Slight gold sheen
      const g = ctx.createLinearGradient(0, 0, 0, c.height);
      g.addColorStop(0, "rgba(212,175,55,.12)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, c.width, c.height);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(2.2, 1);
      return tex;
    }

    function makePlaceholderPhotoTexture(label = "Merry\nChristmas") {
      const c = document.createElement("canvas");
      c.width = 512; c.height = 640;
      const ctx = c.getContext("2d");

      // Background gradient
      const g = ctx.createLinearGradient(0, 0, 0, c.height);
      g.addColorStop(0, "#0b3d2e");
      g.addColorStop(1, "#050708");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, c.width, c.height);

      // Bokeh
      for (let i = 0; i < 70; i++) {
        const x = Math.random() * c.width;
        const y = Math.random() * c.height;
        const r = 10 + Math.random() * 46;
        ctx.beginPath();
        ctx.fillStyle = `rgba(212,175,55,${0.04 + Math.random() * 0.09})`;
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Frame
      ctx.strokeStyle = "rgba(212,175,55,.55)";
      ctx.lineWidth = 10;
      ctx.strokeRect(18, 18, c.width - 36, c.height - 36);

      // Title
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "700 48px ui-sans-serif, system-ui, -apple-system";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const lines = String(label).split("\n");
      lines.forEach((ln, idx) => ctx.fillText(ln, c.width / 2, c.height * 0.55 + idx * 54));

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipMapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      return tex;
    }

    // ---------------------------
    // Three.js Setup
    // ---------------------------
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: false,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;

    const scene = new THREE.Scene();
    scene.background = COLORS.bg0;

    const fog = new THREE.FogExp2(0x050708, 0.085);
    scene.fog = fog;

    const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 120);
    camera.position.set(0, 2.4, 8.6);

    // Postprocessing (cinematic bloom)
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.22,   // strength
      0.55,   // radius
      0.18    // threshold
    );
    composer.addPass(bloomPass);

    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // Lighting: matte green + warm gold + red accents
    scene.add(new THREE.AmbientLight(0xffffff, 0.22));

    const keyLight = new THREE.DirectionalLight(0xfff2d6, 1.05);
    keyLight.position.set(5, 8, 6);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xd4af37, 0.55);
    rimLight.position.set(-6, 4, -6);
    scene.add(rimLight);

    const goldPoint = new THREE.PointLight(0xd4af37, 1.25, 18, 2);
    goldPoint.position.set(0, 4.8, 2.6);
    scene.add(goldPoint);

    const redPoint = new THREE.PointLight(0xb11226, 0.85, 14, 2);
    redPoint.position.set(-2.4, 3.2, 2.4);
    scene.add(redPoint);

    // Tree container
    const tree = new THREE.Group();
    scene.add(tree);

    // Ground subtle
    const groundGeo = new THREE.CircleGeometry(14, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#06110d"),
      roughness: 0.95,
      metalness: 0.05,
      transparent: true,
      opacity: 0.9
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.02;
    tree.add(ground);

    // Star / Top glow
    const starGlowTex = makeRadialSpriteTexture({
      inner: "rgba(212,175,55,1)",
      outer: "rgba(212,175,55,0)"
    });
    const starSpriteMat = new THREE.SpriteMaterial({
      map: starGlowTex,
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      depthWrite: false
    });
    const star = new THREE.Sprite(starSpriteMat);
    star.position.set(0, 4.45, 0);
    star.scale.set(2.25, 2.25, 1);
    tree.add(star);

    const starCore = new THREE.Mesh(
      new THREE.IcosahedronGeometry(0.14, 1),
      new THREE.MeshStandardMaterial({
        color: COLORS.gold,
        emissive: COLORS.gold,
        emissiveIntensity: 2.1,
        metalness: 1.0,
        roughness: 0.22
      })
    );
    starCore.position.copy(star.position);
    tree.add(starCore);

    // ---------------------------
    // Particles (shader-based sparkle cloud)
    // ---------------------------
    const PARTICLE_COUNT = 14000;

    const pGeo = new THREE.BufferGeometry();
    const conePos = new Float32Array(PARTICLE_COUNT * 3);
    const scatterPos = new Float32Array(PARTICLE_COUNT * 3);
    const rand = new Float32Array(PARTICLE_COUNT);
    const size = new Float32Array(PARTICLE_COUNT);

    const treeHeight = 4.6;
    const baseRadius = 1.95;

    function sampleScatter() {
      // Soft volume with a hollow center
      const R = 5.2;
      const u = Math.random();
      const v = Math.random();
      const theta = u * Math.PI * 2;
      const phi = Math.acos(2 * v - 1);
      const rr = (0.45 + Math.pow(Math.random(), 0.65) * 0.55) * R;
      const x = rr * Math.sin(phi) * Math.cos(theta);
      const y = rr * Math.cos(phi) * 0.75 + 1.6;
      const z = rr * Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    function sampleTreeConeDense() {
      // Bias a bit upward to avoid over-crowding the base
      const u = Math.pow(Math.random(), 0.58);
      const y = u * treeHeight;

      const maxR = (1 - (y / treeHeight)) * baseRadius;

      // Volume distribution (fills the interior)
      const rVol = Math.sqrt(Math.random()) * maxR;

      // Shell distribution (keeps a strong silhouette)
      const rShell = maxR * (0.82 + Math.random() * 0.18);

      // Mix: more solid tree while keeping the outline
      const r = lerp(rVol, rShell, 0.62);

      const a = Math.random() * Math.PI * 2;
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;

      // Stronger twist for layered “branches”
      const twist = (1 - y / treeHeight) * 0.65;
      const cx = x * Math.cos(twist) - z * Math.sin(twist);
      const cz = x * Math.sin(twist) + z * Math.cos(twist);

      return new THREE.Vector3(cx, y + 0.12, cz);
    }

    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const c = sampleTreeConeDense();
      const s = sampleScatter();

      conePos[i * 3 + 0] = c.x;
      conePos[i * 3 + 1] = c.y;
      conePos[i * 3 + 2] = c.z;

      scatterPos[i * 3 + 0] = s.x;
      scatterPos[i * 3 + 1] = s.y;
      scatterPos[i * 3 + 2] = s.z;

      rand[i] = Math.random();
      size[i] = 1.2 + Math.random() * 2.6;
    }

    pGeo.setAttribute("aCone", new THREE.BufferAttribute(conePos, 3));
    pGeo.setAttribute("aScatter", new THREE.BufferAttribute(scatterPos, 3));
    pGeo.setAttribute("aRand", new THREE.BufferAttribute(rand, 1));
    pGeo.setAttribute("aSize", new THREE.BufferAttribute(size, 1));

    const pMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },     // 0 cone -> 1 scatter
        uFocus: { value: 0 },   // focus progress
      },
      vertexShader: /* glsl */`
        uniform float uTime;
        uniform float uMix;
        uniform float uFocus;
        attribute vec3 aCone;
        attribute vec3 aScatter;
        attribute float aRand;
        attribute float aSize;
        varying float vRand;
        varying float vGlow;

        void main(){
          vRand = aRand;

          vec3 pos = mix(aCone, aScatter, uMix);

          // subtle float & twinkle
          float t = uTime * (0.7 + aRand * 1.1);
          pos.y += sin(t + aRand * 6.2831) * (0.06 + aRand * 0.10);
          pos.x += cos(t * 1.13 + aRand * 3.1) * (0.03 + aRand * 0.08);
          pos.z += sin(t * 0.97 + aRand * 2.7) * (0.03 + aRand * 0.08);

          // focus: slightly push background away
          float push = uFocus * (0.10 + aRand * 0.18);
          pos *= (1.0 + push);

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = -mv.z;
          float ps = aSize * (260.0 / dist);

          // twinkle intensity (helps bloom)
          vGlow = 0.55 + 0.45 * sin(uTime * 2.2 + aRand * 12.0);

          gl_PointSize = clamp(ps, 1.0, 8.0);
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying float vRand;
        varying float vGlow;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.35, 0.0, d);
          float halo = smoothstep(0.50, 0.15, d) * 0.55;

          vec3 gold = vec3(0.83, 0.69, 0.22);
          vec3 red  = vec3(0.70, 0.07, 0.15);
          vec3 green= vec3(0.04, 0.25, 0.18);

          float m1 = smoothstep(0.25, 0.85, vRand);
          float m2 = smoothstep(0.55, 0.95, vRand);
          vec3 col = mix(green, gold, m1);
          col = mix(col, red, (m2 - 0.55) * 0.8);

          float a = (core + halo) * (0.62 + 0.55 * vGlow);
          if(a < 0.01) discard;

          gl_FragColor = vec4(col * (1.35 + 0.9 * halo), a);
        }
      `
    });

    const particles = new THREE.Points(pGeo, pMat);
    tree.add(particles);

    // ---------------------------
    // Near Orbit Sparkles (rotate around the tree)
    // ---------------------------
    const ORBIT_COUNT = 5200;

    const orbitGeo = new THREE.BufferGeometry();
    const aY = new Float32Array(ORBIT_COUNT);
    const aTheta = new Float32Array(ORBIT_COUNT);
    const aRad = new Float32Array(ORBIT_COUNT);
    const aScatter = new Float32Array(ORBIT_COUNT * 3);
    const aRand2 = new Float32Array(ORBIT_COUNT);
    const aSize2 = new Float32Array(ORBIT_COUNT);

    for (let i = 0; i < ORBIT_COUNT; i++) {
      // y clustered across tree height
      const y = Math.pow(Math.random(), 0.62) * treeHeight + 0.15;
      const maxR = (1 - (y / treeHeight)) * baseRadius;

      // radius slightly outside the tree silhouette (with thickness)
      const rad = maxR * (1.05 + Math.random() * 0.45) + 0.05;

      // spiral distribution
      const theta = i * 0.61803398875 * Math.PI * 2 + Math.random() * 0.35;

      aY[i] = y;
      aTheta[i] = theta;
      aRad[i] = rad;

      // scatter state position
      const s = sampleScatter();
      aScatter[i * 3 + 0] = s.x;
      aScatter[i * 3 + 1] = s.y;
      aScatter[i * 3 + 2] = s.z;

      aRand2[i] = Math.random();
      aSize2[i] = 0.55 + Math.pow(Math.random(), 1.4) * 1.35;
    }

    orbitGeo.setAttribute("aY", new THREE.BufferAttribute(aY, 1));
    orbitGeo.setAttribute("aTheta", new THREE.BufferAttribute(aTheta, 1));
    orbitGeo.setAttribute("aRad", new THREE.BufferAttribute(aRad, 1));
    orbitGeo.setAttribute("aScatter", new THREE.BufferAttribute(aScatter, 3));
    orbitGeo.setAttribute("aRand", new THREE.BufferAttribute(aRand2, 1));
    orbitGeo.setAttribute("aSize", new THREE.BufferAttribute(aSize2, 1));

    const orbitMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },     // 0 cone orbit -> 1 scatter
        uFocus: { value: 0 }
      },
      vertexShader: /* glsl */`
        uniform float uTime;
        uniform float uMix;
        uniform float uFocus;

        attribute float aY;
        attribute float aTheta;
        attribute float aRad;
        attribute vec3  aScatter;
        attribute float aRand;
        attribute float aSize;

        varying float vTw;
        varying float vRand;

        void main(){
          vRand = aRand;

          float spin = uTime * (0.28 + aRand * 0.22);
          float theta = aTheta + spin;

          float y = aY + sin(uTime * (0.9 + aRand) + aTheta) * (0.03 + aRand * 0.05);
          float rad = aRad + sin(uTime * (0.6 + aRand) + aTheta * 1.7) * (0.02 + aRand * 0.05);

          vec3 conePos = vec3(cos(theta) * rad, y, sin(theta) * rad);

          vec3 pos = mix(conePos, aScatter, uMix);

          pos *= (1.0 + uFocus * 0.06);

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = -mv.z;
          float ps = aSize * (230.0 / dist);
          gl_PointSize = clamp(ps, 0.6, 3.2);

          vTw = 0.55 + 0.45 * sin(uTime * 2.0 + aRand * 19.0);
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying float vTw;
        varying float vRand;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.20, 0.0, d);
          float halo = smoothstep(0.55, 0.15, d) * 0.60;

          vec3 gold  = vec3(0.83, 0.69, 0.22);
          vec3 red   = vec3(0.70, 0.07, 0.15);
          vec3 white = vec3(0.96, 0.97, 1.00);

          vec3 col = mix(white, gold, smoothstep(0.10, 0.95, vRand));
          col = mix(col, red, smoothstep(0.86, 0.98, vRand) * 0.30);

          float a = (core + halo) * (0.55 + 0.75 * vTw);
          if(a < 0.01) discard;

          gl_FragColor = vec4(col * (1.25 + halo), a);
        }
      `
    });

    const orbitSparkles = new THREE.Points(orbitGeo, orbitMat);
    tree.add(orbitSparkles);

    // ---------------------------
    // Background Starfield (tiny cinematic sparkles)
    // ---------------------------
    const STAR_COUNT = 12000;
    const starGeo = new THREE.BufferGeometry();

    const starNear = new Float32Array(STAR_COUNT * 3);   // near tree dust
    const starFar  = new Float32Array(STAR_COUNT * 3);   // far sky sphere
    const starRand = new Float32Array(STAR_COUNT);
    const starSize = new Float32Array(STAR_COUNT);

    function sampleSkySphere(R) {
      const u = Math.random();
      const v = Math.random();
      const theta = u * Math.PI * 2;
      const phi = Math.acos(2 * v - 1);
      const rr = (0.55 + Math.pow(Math.random(), 0.55) * 0.45) * R;
      const x = rr * Math.sin(phi) * Math.cos(theta);
      const y = rr * Math.cos(phi) * 0.85 + 1.5;
      const z = rr * Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    for (let i = 0; i < STAR_COUNT; i++) {
      const y = 0.8 + Math.pow(Math.random(), 0.55) * 6.2;
      const r = (0.6 + Math.random() * 0.7) * (2.6 + (1 - y / 7.0) * 2.4);
      const a = Math.random() * Math.PI * 2;
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;

      starNear[i * 3 + 0] = x;
      starNear[i * 3 + 1] = y;
      starNear[i * 3 + 2] = z;

      const far = sampleSkySphere(38);
      starFar[i * 3 + 0] = far.x;
      starFar[i * 3 + 1] = far.y;
      starFar[i * 3 + 2] = far.z;

      starRand[i] = Math.random();
      starSize[i] = 0.35 + Math.pow(Math.random(), 1.6) * 1.25;
    }

    starGeo.setAttribute("aNear", new THREE.BufferAttribute(starNear, 3));
    starGeo.setAttribute("aFar", new THREE.BufferAttribute(starFar, 3));
    starGeo.setAttribute("aRand", new THREE.BufferAttribute(starRand, 1));
    starGeo.setAttribute("aSize", new THREE.BufferAttribute(starSize, 1));

    const starsMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime:  { value: 0 },
        uMix:   { value: 0 },
        uFocus: { value: 0 },
        uOrbit: { value: new THREE.Vector2(0, 0) }
      },
      vertexShader: /* glsl */`
        uniform float uTime;
        uniform float uMix;
        uniform float uFocus;
        uniform vec2  uOrbit;

        attribute vec3 aNear;
        attribute vec3 aFar;
        attribute float aRand;
        attribute float aSize;

        varying float vRand;
        varying float vTw;

        void main(){
          vRand = aRand;

          vec3 pos = mix(aNear, aFar, uMix);

          float t = uTime * (0.35 + aRand * 1.2);
          float drift = (0.20 + 0.55 * uMix) * (1.0 - 0.35 * uFocus);
          pos.x += sin(t + aRand * 12.0 + uOrbit.x * 1.2) * drift;
          pos.y += cos(t * 0.9 + aRand * 9.0  + uOrbit.y * 1.1) * drift * 0.6;
          pos.z += sin(t * 0.8 + aRand * 7.0  + uOrbit.x * 0.9) * drift;

          pos *= (1.0 + uFocus * 0.08);

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = -mv.z;
          float ps = aSize * (220.0 / dist);
          gl_PointSize = clamp(ps, 0.4, 2.4);

          vTw = 0.55 + 0.45 * sin(uTime * 2.0 + aRand * 19.0);
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying float vRand;
        varying float vTw;

        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float core = smoothstep(0.22, 0.0, d);
          float halo = smoothstep(0.50, 0.15, d) * 0.55;

          vec3 gold = vec3(0.83, 0.69, 0.22);
          vec3 red  = vec3(0.70, 0.07, 0.15);
          vec3 white= vec3(0.95, 0.96, 1.00);

          float m = smoothstep(0.15, 0.95, vRand);
          vec3 col = mix(white, gold, m);
          col = mix(col, red, smoothstep(0.82, 0.98, vRand) * 0.35);

          float a = (core + halo) * (0.45 + 0.75 * vTw);
          if(a < 0.01) discard;

          gl_FragColor = vec4(col * (1.2 + halo), a);
        }
      `
    });

    const stars = new THREE.Points(starGeo, starsMat);
    scene.add(stars);

    // ---------------------------
    // Instanced ornaments
    // ---------------------------
    class InstancedOrnaments {
      constructor({ count, geometry, material, scaleRange = [0.08, 0.16], wobble = 0.12 }) {
        this.count = count;
        this.mesh = new THREE.InstancedMesh(geometry, material, count);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        this._cone = new Array(count);
        this._scatter = new Array(count);
        this._scale = new Array(count);
        this._seed = new Array(count);
        this._wobble = wobble;

        for (let i = 0; i < count; i++) {
          this._cone[i] = sampleTreeConeDense();
          this._scatter[i] = sampleScatter();
          this._scale[i] = lerp(scaleRange[0], scaleRange[1], Math.random());
          this._seed[i] = Math.random() * 1000;
        }
        tree.add(this.mesh);
      }

      resampleScatter() {
        for (let i = 0; i < this.count; i++) {
          this._scatter[i] = sampleScatter();
        }
      }

      update({ mix, time, focus, focusDim = 0 }) {
        const obj = new THREE.Object3D();

        for (let i = 0; i < this.count; i++) {
          const a = this._cone[i];
          const b = this._scatter[i];

          const x = lerp(a.x, b.x, mix);
          const y = lerp(a.y, b.y, mix);
          const z = lerp(a.z, b.z, mix);

          const t = time * (0.7 + (this._seed[i] % 1.0) * 1.3);
          const bob = Math.sin(t + this._seed[i]) * this._wobble * (0.6 + (this._seed[i] % 1.0));

          obj.position.set(x, y + bob, z);

          const rotAmp = lerp(0.25, 1.2, mix);
          obj.rotation.set(
            (Math.sin(t * 0.9 + this._seed[i]) * 0.55) * rotAmp,
            (Math.cos(t * 0.7 + this._seed[i] * 0.7) * 0.85) * rotAmp,
            (Math.sin(t * 0.6 + this._seed[i] * 0.4) * 0.35) * rotAmp
          );

          const s = this._scale[i] * (1.0 - focusDim * focus * 0.08);
          obj.scale.setScalar(s);

          obj.updateMatrix();
          this.mesh.setMatrixAt(i, obj.matrix);
        }
        this.mesh.instanceMatrix.needsUpdate = true;
      }
    }

    // Materials (premium: metallic gold / deep red / matte green)
    const goldMat = new THREE.MeshStandardMaterial({
      color: COLORS.gold,
      metalness: 1.0,
      roughness: 0.24,
      emissive: COLORS.gold.clone().multiplyScalar(0.25),
      emissiveIntensity: 1.0
    });

    const redMat = new THREE.MeshStandardMaterial({
      color: COLORS.red,
      metalness: 0.65,
      roughness: 0.32,
      emissive: COLORS.red.clone().multiplyScalar(0.20),
      emissiveIntensity: 1.0
    });

    const greenMat = new THREE.MeshStandardMaterial({
      color: COLORS.matteGreen,
      metalness: 0.18,
      roughness: 0.85,
      emissive: COLORS.matteGreen.clone().multiplyScalar(0.18),
      emissiveIntensity: 0.9
    });

    const stripeTex = makeStripeTexture();
    const candyMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.35,
      roughness: 0.55,
      map: stripeTex,
      emissive: new THREE.Color("#ffffff").multiplyScalar(0.08),
      emissiveIntensity: 0.9
    });

    // Geometries (small ornaments)
    const sphereGeo = new THREE.SphereGeometry(0.02, 16, 16);
    const cubeGeo   = new THREE.BoxGeometry(0.03, 0.03, 0.03);
    const candyGeo  = new THREE.CylinderGeometry(0.012, 0.012, 0.10, 14, 1, true);

    // Instances (dense)
    const goldBalls   = new InstancedOrnaments({ count: 900, geometry: sphereGeo, material: goldMat,  scaleRange: [0.9, 1.7], wobble: 0.12 });
    const redBalls    = new InstancedOrnaments({ count: 650, geometry: sphereGeo, material: redMat,   scaleRange: [0.9, 1.6], wobble: 0.13 });
    const greenCubes  = new InstancedOrnaments({ count: 420, geometry: cubeGeo,   material: greenMat, scaleRange: [0.9, 1.5], wobble: 0.09 });
    const candySticks = new InstancedOrnaments({ count: 260, geometry: candyGeo,  scaleRange: [0.9, 1.7], material: candyMat, wobble: 0.10 });

    // ---------------------------
    // Photo Cloud
    // ---------------------------
    const photosGroup = new THREE.Group();
    tree.add(photosGroup);

    const photoItems = [];
    let focusedIndex = -1;

    function makePhotoMaterial(tex) {
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      // Basic: stable and bloom-friendly on mobile
      return new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        opacity: 1.0
      });
    }

    function addPhotoTexture(tex) {
      const aspect = tex.image ? (tex.image.width / tex.image.height) : 0.8;
      const h = 0.12;
      const w = h * clamp(aspect, 0.55, 1.55);

      const geo = new THREE.PlaneGeometry(w, h, 1, 1);
      const mat = makePhotoMaterial(tex);
      const mesh = new THREE.Mesh(geo, mat);

      mesh.renderOrder = 2;
      mesh.userData = {
        cone: (() => {
          const v = sampleTreeConeDense();
          // Push outward so photos sit closer to the “outer layer”
          const push = 1.10;
          v.x *= push;
          v.z *= push;
          return v;
        })(),
        scatter: sampleScatter(),
        baseScale: 1.0,
        seed: Math.random() * 1000,
        w, h
      };

      // Gold frame
      const frameGeo = new THREE.PlaneGeometry(w * 1.06, h * 1.06);
      const frameMat = new THREE.MeshStandardMaterial({
        color: COLORS.gold,
        metalness: 1.0,
        roughness: 0.28,
        emissive: COLORS.gold.clone().multiplyScalar(0.22),
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0.82
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.z = -0.01;
      mesh.add(frame);

      photosGroup.add(mesh);
      photoItems.push(mesh);
      if (focusedIndex === -1) focusedIndex = 0;
    }

    // Default placeholder photos (before upload)
    for (let i = 0; i < 6; i++) addPhotoTexture(makePlaceholderPhotoTexture(i % 2 ? "Merry\nChristmas" : "Happy\nHolidays"));

    async function loadFiles(files) {
      // Clear old
      for (const m of photoItems.splice(0, photoItems.length)) {
        photosGroup.remove(m);
        m.geometry.dispose();
        if (m.material?.map) m.material.map.dispose();
        m.material?.dispose?.();
      }
      focusedIndex = -1;

      const list = Array.from(files || []).slice(0, 100);
      if (!list.length) {
        for (let i = 0; i < 6; i++) addPhotoTexture(makePlaceholderPhotoTexture("Merry\nChristmas"));
        return;
      }

      const loader = new THREE.TextureLoader();
      for (const f of list) {
        const url = URL.createObjectURL(f);
        await new Promise((resolve) => {
          loader.load(
            url,
            (tex) => {
              addPhotoTexture(tex);
              URL.revokeObjectURL(url);
              resolve();
            },
            undefined,
            () => { URL.revokeObjectURL(url); resolve(); }
          );
        });
      }
    }

    fileInput.addEventListener("change", (e) => {
      loadFiles(e.target.files);
    });

    // ---------------------------
    // State Machine
    // ---------------------------
    const Mode = {
      CONE: "CONE",
      SCATTER: "SCATTER",
      FOCUS: "FOCUS"
    };

    let mode = Mode.CONE;
    let targetMix = 0;
    let mix = 0;

    let focus = 0;
    let targetFocus = 0;

    const greetings = [
      "Wishing you a season filled with warmth, peace, and good fortune.\nMerry Christmas & Happy New Year.",
      "May your holidays sparkle with joy, and your wishes find their way home.",
      "Sending you golden light and kind thoughts.\nWishing you peace, joy, and abundance.",
      "May every reunion shine bright, and every new journey feel fearless.",
      "Merry Christmas.\nMay your days be as bright as the star on top.",
      "Wishing you wonderful moments, smooth paths ahead, and a brilliant New Year."
    ];

    function setMode(next) {
      if (mode === next) return;
      mode = next;

      if (mode === Mode.CONE) {
        targetMix = 0;
        targetFocus = 0;
        hideFocusOverlay();
      } else if (mode === Mode.SCATTER) {
        targetMix = 1;
        targetFocus = 0;
        hideFocusOverlay();
      } else if (mode === Mode.FOCUS) {
        targetMix = 1;     // background stays scatter
        targetFocus = 1;
        showFocusOverlay();
      }
    }

    function showFocusOverlay() {
      focusOverlay.classList.add("show");
    }
    function hideFocusOverlay() {
      focusOverlay.classList.remove("show");
    }

    function pickRandomPhotoAndGreeting() {
      if (!photoItems.length) return;
      focusedIndex = Math.floor(Math.random() * photoItems.length);
      const g = greetings[Math.floor(Math.random() * greetings.length)];
      focusTextEl.textContent = g;
    }

    // ---------------------------
    // Camera control (hand-driven + touch fallback)
    // ---------------------------
    let yaw = 0.0, pitch = 0.18, radius = 8.6;
    let yawT = yaw, pitchT = pitch;

    function applyCamera(dt) {
      // subtle auto orbit in cone state
      if (mode === Mode.CONE) {
        yawT += dt * 0.22;
        pitchT = damp(pitchT, 0.16, 2.5, dt);
      } else if (mode === Mode.SCATTER) {
        pitchT = clamp(pitchT, -0.22, 0.62);
      } else if (mode === Mode.FOCUS) {
        pitchT = damp(pitchT, 0.15, 3.0, dt);
      }

      yaw = damp(yaw, yawT, 6.2, dt);
      pitch = damp(pitch, pitchT, 6.2, dt);

      const r = radius;
      const cx = Math.sin(yaw) * Math.cos(pitch) * r;
      const cy = 2.25 + Math.sin(pitch) * r * 0.35;
      const cz = Math.cos(yaw) * Math.cos(pitch) * r;

      camera.position.set(cx, cy, cz);
      camera.lookAt(0, 2.35, 0);

      // light reacts slightly (premium feel)
      goldPoint.position.set(
        Math.sin(yaw * 0.7) * 1.8,
        4.7 + Math.sin(perfTime * 0.7) * 0.12,
        2.4 + Math.cos(yaw * 0.7) * 1.2
      );
    }

    // Touch fallback
    let dragging = false;
    let lastX = 0, lastY = 0;
    let lastTap = 0;

    canvas.addEventListener("pointerdown", (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener("pointerup", () => dragging = false);
    window.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      if (mode !== Mode.SCATTER) return;
      yawT += dx * 0.0042;
      pitchT += dy * 0.0034;
    });

    canvas.addEventListener("click", () => {
      // double tap to “click” in touch mode
      const now = performance.now();
      if (now - lastTap < 360) {
        if (mode === Mode.SCATTER) {
          pickRandomPhotoAndGreeting();
          setMode(Mode.FOCUS);
        } else if (mode === Mode.FOCUS) {
          pickRandomPhotoAndGreeting();
        }
      }
      lastTap = now;
    });

    // ---------------------------
    // MediaPipe Hands (gesture detection)
    // ---------------------------
    let hands = null;
    let handEnabled = false;

    let lastLandmarks = null;
    let lastLandmarksTs = 0;

    // pinch edge detection
    let pinchDown = false;
    let pinchCooldown = 0;

    function dist2(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dz = (a.z || 0) - (b.z || 0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    function computeGesture(landmarks) {
      // palm center from wrist + MCPs
      const palmIdx = [0, 5, 9, 13, 17];
      const palm = { x: 0, y: 0, z: 0 };
      for (const i of palmIdx) {
        palm.x += landmarks[i].x;
        palm.y += landmarks[i].y;
        palm.z += landmarks[i].z;
      }
      palm.x /= palmIdx.length;
      palm.y /= palmIdx.length;
      palm.z /= palmIdx.length;

      const wrist = landmarks[0];
      const handSize = Math.max(1e-6, dist2(wrist, landmarks[9])); // wrist -> middle MCP

      const tips = [4, 8, 12, 16, 20];
      let avgTipPalm = 0;
      for (const t of tips) avgTipPalm += dist2(landmarks[t], palm);
      avgTipPalm /= tips.length;
      const pinchMetric = avgTipPalm / handSize;

      function extended(tip, pip) {
        const dt = dist2(landmarks[tip], wrist);
        const dp = dist2(landmarks[pip], wrist);
        return dt > dp * 1.12;
      }
      const thumbExt  = extended(4, 2);
      const indexExt  = extended(8, 6);
      const middleExt = extended(12, 10);
      const ringExt   = extended(16, 14);
      const pinkyExt  = extended(20, 18);
      const extCount = [thumbExt, indexExt, middleExt, ringExt, pinkyExt].filter(Boolean).length;

      // click: thumb-index pinch
      const pinch = (dist2(landmarks[4], landmarks[8]) / handSize) < 0.38;

      const indexTip = landmarks[8];

      // open/close classification
      const openHand = (extCount >= 4) || (pinchMetric > 1.20);
      const closeHand = (extCount <= 1) && (pinchMetric < 0.88);

      const indexOnly = indexExt && !middleExt && !ringExt && !pinkyExt;

      return {
        palm,
        indexTip,
        pinchMetric,
        extCount,
        openHand,
        closeHand,
        indexOnly,
        pinch
      };
    }

    let lastPalmX = null, lastPalmY = null;

    function handleGesture(g, dt) {
      // Priority: open/close overrides
      if (g.openHand) {
        setMode(Mode.SCATTER);
      } else if (g.closeHand) {
        setMode(Mode.CONE);
      }

      // pinch edge
      pinchCooldown = Math.max(0, pinchCooldown - dt);

      const pinchPressed = g.pinch && pinchCooldown <= 0;
      if (pinchPressed && !pinchDown) {
        pinchDown = true;

        if (mode === Mode.SCATTER) {
          pickRandomPhotoAndGreeting();
          setMode(Mode.FOCUS);
        } else if (mode === Mode.FOCUS) {
          pickRandomPhotoAndGreeting();
        }

        pinchCooldown = 0.45;
      }
      if (!g.pinch) pinchDown = false;

      // Rotate in scatter mode by palm movement
      if (mode === Mode.SCATTER && !g.pinch && !g.closeHand) {
        const x = g.palm.x; // 0..1
        const y = g.palm.y; // 0..1

        if (lastPalmX != null) {
          const dx = x - lastPalmX;
          const dy = y - lastPalmY;

          // Dead-zone to reduce micro jitter
          const dead = 0.0025;
          const ddx = Math.abs(dx) < dead ? 0 : dx;
          const ddy = Math.abs(dy) < dead ? 0 : dy;

          yawT   += (-ddx) * 4.2;
          pitchT += ( ddy) * 3.0;
        }

        lastPalmX = x;
        lastPalmY = y;
      } else {
        lastPalmX = lastPalmY = null;
      }
    }

    async function startHands() {
      if (!window.Hands) {
        statusText.textContent = "MediaPipe Hands not loaded (check your network)";
        return;
      }
      if (!navigator.mediaDevices?.getUserMedia) {
        statusText.textContent = "This browser does not support camera permissions";
        return;
      }

      hands = new window.Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });
      hands.onResults((results) => {
        const lm = results.multiHandLandmarks?.[0] || null;
        if (lm) {
          lastLandmarks = lm;
          lastLandmarksTs = performance.now();
        }
      });

      // getUserMedia (manual loop; mobile-friendly)
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: "user",
          width: { ideal: 640 },
          height: { ideal: 480 }
        }
      });

      videoEl.srcObject = stream;
      await videoEl.play();

      handEnabled = true;
      led.classList.add("on");
      statusText.textContent = "Hand tracking on: open/close/rotate/pinch to pick";

      // processing loop (throttled)
      let busy = false;
      let lastSent = 0;

      async function pump() {
        if (!handEnabled) return;
        const now = performance.now();
        // ~30fps target
        if (!busy && (now - lastSent) > 33) {
          busy = true;
          lastSent = now;
          try {
            await hands.send({ image: videoEl });
          } catch (e) {
            // ignore transient errors
          }
          busy = false;
        }
        requestAnimationFrame(pump);
      }
      pump();
    }

    btnStart.addEventListener("click", async () => {
      try {
        btnStart.disabled = true;
        btnStart.textContent = "Enabling...";
        await startHands();
        btnStart.textContent = "Hand Tracking Enabled";
      } catch (e) {
        statusText.textContent = "Failed to enable: allow camera access and make sure you are on HTTPS";
        btnStart.disabled = false;
        btnStart.textContent = "Enable Hand Tracking";
      }
    });

    btnReset.addEventListener("click", () => {
      setMode(Mode.CONE);
      goldBalls.resampleScatter();
      redBalls.resampleScatter();
      greenCubes.resampleScatter();
      candySticks.resampleScatter();
      for (const p of photoItems) p.userData.scatter = sampleScatter();
      pickRandomPhotoAndGreeting();
    });

    btnHelp.addEventListener("click", () => {
      tips.style.display = (tips.style.display === "none") ? "flex" : "none";
    });

    // ---------------------------
    // Photo update per frame (billboard + focus)
    // ---------------------------
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();

    function updatePhotos({ mix, time, focus }) {
      const focusPos = new THREE.Vector3(0, 2.2, 1.15);
      const focusScale = 15;

      for (let i = 0; i < photoItems.length; i++) {
        const m = photoItems[i];
        const ud = m.userData;

        const a = ud.cone;
        const b = ud.scatter;

        const x = lerp(a.x, b.x, mix);
        const y = lerp(a.y, b.y, mix);
        const z = lerp(a.z, b.z, mix);

        const t = time * (0.7 + (ud.seed % 1.0) * 1.1);
        const bob = Math.sin(t + ud.seed) * 0.10;

        tmpV.set(x, y + bob, z);

        const isFocused = (mode === Mode.FOCUS && i === focusedIndex);

        if (mode === Mode.FOCUS) {
          if (isFocused) {
            tmpV.lerp(focusPos, focus);
            const s = lerp(1.0, focusScale, focus);
            m.scale.setScalar(s);
            m.material.opacity = 1.0;
          } else {
            m.scale.setScalar(1.0);
            m.material.opacity = lerp(1.0, 0.72, focus);
            tmpV.multiplyScalar(1.0 + focus * 0.10);
          }
        } else {
          m.scale.setScalar(1.0);
          m.material.opacity = 1.0;
        }

        m.position.copy(tmpV);

        tmpV2.copy(camera.position);
        m.lookAt(tmpV2);

        const tilt = (1.0 - (isFocused ? focus : 0.0));
        m.rotateZ(Math.sin(t * 0.6) * 0.06 * tilt);
      }
    }

    // ---------------------------
    // Render Loop
    // ---------------------------
    let perfTime = 0;
    let lastTime = performance.now();

    function updateBackground(dt) {
      if (mode === Mode.CONE) {
        bloomPass.strength = damp(bloomPass.strength, 1.20, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.56, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.18, 2.8, dt);
        fog.density        = damp(fog.density,        0.090,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.15, 2.2, dt);
      } else if (mode === Mode.SCATTER) {
        bloomPass.strength = damp(bloomPass.strength, 1.26, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.62, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.17, 2.8, dt);
        fog.density        = damp(fog.density,        0.078,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.18, 2.2, dt);
      } else {
        bloomPass.strength = damp(bloomPass.strength, 1.38, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.70, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.15, 2.8, dt);
        fog.density        = damp(fog.density,        0.070,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.22, 2.2, dt);
      }
    }

    function animate() {
      const now = performance.now();
      const dt = clamp((now - lastTime) / 1000, 0.0, 0.035);
      lastTime = now;
      perfTime += dt;

      // Gesture update if recent
      if (handEnabled && lastLandmarks && (now - lastLandmarksTs) < 180) {
        const g = computeGesture(lastLandmarks);
        handleGesture(g, dt);
      }

      // Smooth transitions
      mix = damp(mix, targetMix, 2.8, dt);
      targetFocus = (mode === Mode.FOCUS) ? 1 : 0;
      focus = damp(focus, targetFocus, 4.2, dt);

      // Shader uniforms
      pMat.uniforms.uTime.value = perfTime;
      pMat.uniforms.uMix.value = mix;
      pMat.uniforms.uFocus.value = focus;

      starsMat.uniforms.uTime.value = perfTime;
      starsMat.uniforms.uMix.value = mix;
      starsMat.uniforms.uFocus.value = focus;
      starsMat.uniforms.uOrbit.value.set(yaw, pitch);

      orbitMat.uniforms.uTime.value = perfTime;
      orbitMat.uniforms.uMix.value = mix;
      orbitMat.uniforms.uFocus.value = focus;

      // Ornaments
      goldBalls.update({ mix, time: perfTime, focus, focusDim: 1 });
      redBalls.update({ mix, time: perfTime, focus, focusDim: 1 });
      greenCubes.update({ mix, time: perfTime, focus, focusDim: 1 });
      candySticks.update({ mix, time: perfTime, focus, focusDim: 1 });

      // Star shimmer
      star.material.opacity = 0.78 + Math.sin(perfTime * 2.2) * 0.10;
      star.scale.setScalar(2.15 + Math.sin(perfTime * 1.7) * 0.10);
      starCore.rotation.y += dt * 0.6;

      // Photos
      updatePhotos({ mix, time: perfTime, focus });

      // Camera
      applyCamera(dt);

      // Background mood
      updateBackground(dt);

      composer.render();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Initial greeting
    pickRandomPhotoAndGreeting();

    // Resize
    function onResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.setSize(w, h, false);
      composer.setSize(w, h);
    }
    window.addEventListener("resize", onResize);

    // Initial status
    statusText.textContent = "Default: Cone mode (enable hand tracking / upload photos)";
  </script>
</body>
</html>
